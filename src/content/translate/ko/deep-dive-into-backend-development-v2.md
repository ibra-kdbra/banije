---
title: "고급 백엔드 엔지니어링 - 분산 시스템에서 탄력적인 아키텍처까지"
published: 2025-05-12
description: "확장 가능하고 내결함성이 있는 애플리케이션을 구축하기 위한 일관성 모델, 탄력성 패턴, 이벤트 소싱, CQRS 및 현대적인 백엔드 아키텍처를 다루는 분산 시스템에 대한 고급 가이드입니다."
image: ''
tags: [Backend, Distributed Systems, Architecture, Resilience, CQRS, Event Sourcing, Microservices]
category: Backend Development
draft: false
lang: "ko"
originalSlug: "deep-dive-into-backend-development-v2"
series:
  name: "Backend Engineering"
  order: 2
---

## 1.0 서론: 분산의 피할 수 없는 법칙

이 시리즈의 버전 1.0은 백엔드 엔지니어링의 역할, 도구 및 초기 아키텍처 패턴을 정의하는 토대를 마련했습니다. 모놀리스와 마이크로서비스, SQL과 NoSQL, REST와 GraphQL을 살펴보았습니다. 그 지식은 기능적인 애플리케이션을 구축하는 데 필요한 기초를 나타냅니다. 그러나 이 책은 이러한 애플리케이션을 확장할 때 발생하는 일에 관한 것입니다. 즉, 단일 서버가 플릿이 되고, 단일 데이터베이스가 클러스터가 되며, 프로세스 내 호출이 네트워크 홉이 될 때입니다. 이것이 바로 **분산 시스템**의 영역이며, 이는 더 다르고 가혹한 규칙 세트에 의해 지배됩니다.

단일 머신 시스템에서 분산 시스템으로의 전환은 복잡성이 선형적으로 증가하는 것이 아닙니다. 그것은 패러다임 전환입니다. 단일 머신에서 유효한 가정들(신뢰할 수 있는 네트워킹, 제로 대기 시간, 즉각적인 작업)이 산산조각 납니다. 고급 백엔드 엔지니어의 주요 목표는 기본 환경의 본질적인 불안정성에도 불구하고 정확하고 안정적으로 작동할 수 있는 시스템을 구축하는 것입니다.

### 1.1 분산 컴퓨팅의 8가지 오류

1990년대에 Sun Microsystems의 L. Peter Deutsch와 동료들은 분산 애플리케이션을 처음 접하는 프로그래머들이 예외 없이 저지르는 위험한 가정들인 '오류' 목록을 정리했습니다.

:::caution[분산 컴퓨팅의 8가지 오류]

1. **네트워크는 신뢰할 수 있다.** (그렇지 않습니다.)
2. **지연 시간은 제로다.** (그렇지 않습니다.)
3. **대역폭은 무한하다.** (그렇지 않습니다.)
4. **네트워크는 안전하다.** (그렇지 않습니다.)
5. **토폴로지는 변하지 않는다.** (변합니다.)
6. **관리자는 한 명이다.** (많습니다.)
7. **운송 비용은 제로다.** (그렇지 않습니다.)
8. **네트워크는 균질하다.** (그렇지 않습니다.)

:::

이 책에서 논의되는 모든 패턴, 프로토콜 및 아키텍처는 어떤 면에서 이러한 오류의 결과를 완화하기 위한 전략입니다.

### 1.2 고급 백엔드 엔지니어링을 위한 로드맵

우리의 토대를 바탕으로 현대 시스템 아키텍처를 정의하는 고급 주제를 살펴봅니다.

* **섹션 2: 고급 데이터 관리 및 일관성**
* **섹션 3: 탄력적 시스템 설계 패턴**
* **섹션 4: 고급 비동기 통신**
* **섹션 5: 대규모 성능 엔지니어링**
* **섹션 6: 고급 API 및 보안 아키텍처**

## 2.0 고급 데이터 관리 및 일관성

하나의 데이터베이스가 있는 단일 서버 애플리케이션에서 데이터 일관성은 주로 ACID 트랜잭션을 통해 해결됩니다. 분산 시스템에서 일관성은 가장 어려운 과제 중 하나가 됩니다.

### 2.1 일관성 스펙트럼과 PACELC 정리

CAP 정리는 네트워크 분할 중의 동작을 설명하지만, **PACELC 정리**는 더 완전한 그림을 제공합니다.

:::note[PACELC 정리]
**"분할(P)이 있는 경우 분산 시스템은 가용성(A)과 일관성(C) 중 하나를 선택해야 합니다. 그렇지 않으면(E) 시스템이 정상적으로 실행될 때 지연 시간(L)과 일관성(C) 중 하나를 선택해야 합니다."**
:::

이는 미묘한 아키텍처 논의를 강제합니다. 시스템은 장애 발생 시 가용성을 위해 일관성을 희생할 수 있지만 정상 작동 중에는 지연 시간보다 일관성을 우선시할 수 있습니다.

### 2.2 분산 트랜잭션: 사가(Saga) 패턴

2단계 커밋은 동기식이며 마이크로서비스에는 적합하지 않습니다. **사가 패턴**은 로컬 트랜잭션과 보상 작업을 통해 서비스 간의 데이터 일관성을 관리합니다.

:::tip[사가 패턴 예시: 이커머스 주문]

1. `주문 서비스`: `PENDING` 상태로 주문 생성, `ORDER_CREATED` 이벤트 게시
2. `결제 서비스`: 결제 처리, 성공 시 `PAYMENT_PROCESSED` 게시
3. `재고 서비스`: 재고 업데이트, 성공 시 `INVENTORY_UPDATED` 게시
4. `주문 서비스`: 주문을 `CONFIRMED`로 업데이트

**실패 처리:** 재고가 실패한 경우 결제 서비스는 환불로 보상하고 주문 서비스는 취소합니다.
:::

**구현 스타일:**

:::note[사가 구현 접근 방식]

* **코레오그래피(Choreography):** 중앙 조정자 없이 서비스가 이벤트를 게시/구독함
* **오케스트레이션(Orchestration):** 중앙 오케스트레이터가 사가 상태 및 보상 트랜잭션을 관리함

:::

### 2.3 이벤트 소싱 및 CQRS

이러한 패턴은 확장성이 뛰어나고 감사 가능한 시스템을 구축합니다.

* **이벤트 소싱:** 현재 상태 대신 변경 불가능한 이벤트를 저장합니다. 현재 상태는 이벤트를 다시 재생하여 파생됩니다.

:::note[이벤트 소싱 예시]

```json
// 잔액 80을 저장하는 대신 이벤트 시퀀스 저장:
[
  {"type": "AccountCreated", "initialBalance": 0},
  {"type": "DepositMade", "amount": 100},
  {"type": "WithdrawalMade", "amount": 20}
]
// 현재 잔액 = 이벤트 재생
```

:::

* **CQRS (Command Query Responsibility Segregation):** 쓰기 모델을 읽기 모델에서 분리합니다.

:::tip[CQRS 이점]

* 쓰기 대 읽기에 최적화된 서로 다른 모델
* 명령 및 조회 측면의 독립적 확장
* 별도의 컨텍스트를 사용한 더 나은 도메인 모델링

:::

### 2.4 백엔드 엔지니어를 위한 데이터베이스 내부 구조

스토리지 엔진과 복제 전략을 이해하는 것은 성능과 안정성에 중요합니다.

:::note[MySQL 스토리지 엔진]

* **InnoDB:** OLTP 워크로드를 위한 트랜잭션, ACID 준수, 행 수준 잠금
* **MyISAM:** 빠른 읽기, 테이블 수준 잠금, 트랜잭션 없음(새로운 앱에서는 더 이상 사용되지 않음)

:::

**복제 전략:**

:::tip[복제 모델]

* **리더-팔로워:** 리더에 대한 모든 쓰기, 복제본에서 읽기(가장 일반적)
* **다중 리더:** 여러 노드가 쓰기를 허용하며 복제 충돌이 해결되어야 함
* **리더리스(Cassandra 스타일):** 여러 노드에 동시에 쓰기, 쿼럼 읽기

:::

**트랜잭션 격리 수준 (SQL):**

:::note[SQL 격리 수준]

1. **Read Uncommitted:** 커밋되지 않은 변경 사항을 읽을 수 있음(더티 리드)
2. **Read Committed:** 커밋된 변경 사항만 읽음(반복 불가능한 읽기 가능)
3. **Repeatable Read:** 트랜잭션 내에서 일관된 행 값(팬텀 리드 가능)
4. **Serializable:** 전체 직렬 실행(최고의 일관성, 최저 성능)

:::

## 3.0 탄력적 시스템 설계 패턴

탄력성은 장애로부터 복구하고 계속 작동하는 능력입니다. 장애를 완전히 방지하기보다는 장애를 우아하게 처리하는 것입니다.

### 3.1 서킷 브레이커(Circuit Breaker) 패턴 (심층 분석)

서킷 브레이커는 오류를 모니터링하고 분산 시스템에서 연쇄 오류를 방지합니다.

:::note[서킷 브레이커 상태]

* **Closed:** 정상 작동, 요청이 전달됨, 실패 모니터링
* **Open:** 다운스트림 문제에 대해 즉시 실패, 재시도 전 타임아웃
* **Half-Open:** 단일 프로브 요청으로 다운스트림 복구 테스트

:::

### 3.2 벌크헤드(Bulkhead) 패턴

단일 실패가 전체 시스템에 영향을 미치는 것을 방지하기 위해 애플리케이션 구성 요소를 풀로 격리합니다.

:::tip[벌크헤드 구현]
각 다운스트림 서비스에 대해 별도의 스레드/연결 풀을 사용하십시오. 느린 서비스 A는 서비스 B의 풀에 영향을 주지 않아 전체 시스템 오류를 방지합니다.
:::

### 3.3 재시도 및 타임아웃 패턴

분산 시스템에서 일시적인 오류를 처리하는 데 필수적입니다.

:::caution[재시도 모범 사례]

* **타임아웃:** 공격적인 타임아웃은 리소스 고갈을 방지함
* **지수 백오프:** 재시도 간격 증가(1s, 2s, 4s, 8s)
* **지터(Jitter):** 뇌성 벽력(thundering herd) 문제를 방지하기 위해 무작위성 추가

:::

### 3.4 속도 제한 및 부하 차단

과부하로부터 서비스를 보호하고 우아한 성능 저하를 구현합니다.

:::note[속도 제한 전략]

* **토큰 버킷:** 요청에 대해 토큰이 쌓이고 사용 시 제거됨
* **리키 버킷(Leaky Bucket):** 고정된 속도로 요청 처리, 초과분은 폐기됨
* **부하 차단(Load Shedding):** 극심한 부하 상황에서 우선순위가 낮은 요청을 거부함

:::

## 4.0 고급 비동기 통신

비동기 패턴은 탄력적이고 느슨하게 결합된 분산 시스템의 기본입니다.

### 4.1 메시지 브로커 대 이벤트 로그

서로 다른 절충점을 가진 메시징 접근 방식입니다.

:::tip[메시지 브로커 특성]

* **RabbitMQ:** 스마트 라우팅, 작업 큐잉, 메시지 브로커 모델
* **Apache Kafka:** 이벤트 스트리밍, 영구 로그, 다중 소비자

:::

### 4.2 멱등적 소비자

메시징 시스템에서 "최소 한 번" 전달을 처리하는 데 중요합니다.

:::note[멱등성 전략]

```text
function processMessage(message) {
  if (processedMessages.contains(message.id)) {
    return; // 중복 건너뛰기
  }

  // 메시지 처리
  processBusinessLogic(message);

  // 처리된 것으로 추적 (비즈니스 로직과 원자적이어야 함)
  processedMessages.add(message.id);
}
```

:::

### 4.3 트랜잭션 아웃박스(Transactional Outbox) 패턴

이벤트 중심 시스템에서 원자적 데이터베이스 업데이트 및 이벤트 게시 문제를 해결합니다.

:::tip[트랜잭션 아웃박스 흐름]

1. 단일 로컬 트랜잭션에서 비즈니스 엔터티 업데이트 및 아웃박스에 이벤트 삽입
2. 메시지 릴레이가 비동기적으로 이벤트를 게시하고 전송된 것으로 표시
3. 분산 트랜잭션 없이 원자성 보장
4. "최소 한 번" 전달 의미 체계 제공

:::

## 5.0 대규모 성능 엔지니어링

병목 현상을 식별하고 제거하는 체계적인 규율입니다.

### 5.1 캐싱 패턴 (심층 분석)

기본적인 cache-aside를 넘어선 고급 캐싱 전략입니다.

:::note[캐싱 패턴 비교]

* **Cache-Aside:** 앱 코드가 캐시 관리, 지연 로딩
* **Read-Through:** 캐시가 DB에서 데이터 로딩 처리
* **Write-Through:** 캐시 업데이트 시 동기적으로 DB 업데이트
* **Write-Back:** 캐시 업데이트 시 비동기적으로 DB에 플러시

:::

**뇌성 벽력(Thundering Herd) 완화:**

:::caution[뇌성 벽력 문제]
캐시된 항목이 만료되면 수천 개의 요청이 동시에 캐시 미스가 발생하여 DB를 압도합니다. 해결책: 첫 번째 요청만 데이터를 로드하고 다른 요청은 기다리는 잠금 기반 다시 가져오기입니다.
:::

### 5.2 동시성 대 병렬성

성능 최적화를 위한 기본 개념입니다.

:::tip[워크로드 매칭]

* **I/O 바운드 워크로드:** 비동기 모델(Node.js, asyncio)이 많은 동시 요청 처리
* **CPU 바운드 워크로드:** 병렬성(Go, Java)이 다중 코어 활용

:::

### 5.3 프로파일링 및 성능 튜닝

측정할 수 없는 것은 최적화할 수 없습니다.

:::note[성능 프로파일링]
프로파일러를 사용하여 다음을 식별하는 플레임 그래프를 생성하십시오.

* 코드 실행 경로의 CPU 핫스팟
* 메모리 할당 패턴 및 누수
* I/O 병목 현상 및 대기 시간

:::

## 6.0 고급 API 및 보안 아키텍처

분산 환경의 복잡성을 관리하기 위한 인프라 수준의 솔루션입니다.

### 6.1 API 게이트웨이 패턴

클라이언트와 서비스 간의 통신을 관리하는 단일 진입점입니다.

:::tip[API 게이트웨이 책임]

* **라우팅:** 적절한 마이크로서비스로 요청 전달
* **인증/권한 부여:** 에지에서 자격 증명 확인
* **속도 제한:** 사용 정책 및 스로틀링 시행
* **요청 변환:** 다운스트림 서비스에 맞게 요청 조정
* **관찰 가능성:** 중앙 집중식 로깅 및 모니터링

:::

### 6.2 서비스 메시(Service Mesh)

안전하고 빠르며 신뢰할 수 있는 서비스 간 통신을 위한 인프라 계층입니다.

:::note[서비스 메시 구성 요소]

* **사이드카 프록시:** (Envoy) 서비스당 모든 인바운드/아웃바운드 트래픽 처리
* **제어 평면:** (Istio, Linkerd) 모든 사이드카 프록시 구성
* **기능:** mTLS, 트래픽 관리, 분산 추적, 관찰 가능성

:::

### 6.3 제로 트러스트 보안

분산 시스템을 위한 "절대 신뢰하지 말고 항상 확인하라"는 보안 모델입니다.

:::caution[제로 트러스트 원칙]

* **ID 기반 인증:** 출처에 관계없이 모든 요청 확인
* **최소 권한 액세스:** 필요한 최소한의 권한 부여
* **침해 가정:** 내부 침해를 예상하고 설계

:::

### 6.4 JWT (심층 분석): 위험 및 완화

JWT 취약점 및 안전한 구현 이해.

:::caution[JWT 보안 문제]

* **알고리즘 혼동 공격:** 서버를 속여 약한 알고리즘을 사용하게 함
  * *완화:* 강력한 알고리즘(RS256)만 허용하도록 라이브러리 구성
* **토큰 취소:** 상태 비저장 토큰은 무효화할 수 없음
  * *완화:* 빠른 캐시에서 취소 거부 목록 유지

:::

## 7.0 결론: 원칙 있는 엔지니어

버전 2.0은 분산 시스템 엔지니어링을 여행했습니다. 탄력적이고 확장 가능한 백엔드 시스템을 구축하려면 지연 시간 대 일관성, 가용성 대 정확성, 속도 대 안전성과 같은 기본 절충안에 대한 깊은 이해가 필요합니다.

고급 백엔드 엔지니어는 실패를 고려하여 설계하고, 네트워크 적대성을 가정하며, 사가, 이벤트 소싱, 서킷 브레이커, 서비스 메시와 같은 패턴을 적용합니다. 궁극적인 기술은 복잡성을 추론하는 것입니다. 즉, 적절한 완화 전략을 적용하기 위해 실패 지점, 병목 현상 및 취약점을 식별하는 것입니다.
